package edu.stthomas.gps;

import java.io.IOException;
import java.net.URI;
import java.util.ArrayList;
import java.util.Random;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.SequenceFile;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Mapper.Context;

public class NeuronGraphMapper extends Mapper<IntWritable, NeuronWritable, IntWritable, NeuronStateWritable> {

	private IntWritable neuron_id = new IntWritable(); // key
	private NeuronStateWritable neuron_state = new NeuronStateWritable();
	private IntWritable adj_id = new IntWritable();
	private AdjListWritable adjlist_writable = new AdjListWritable();
	private Random randn = new Random();
	private boolean firstCalled;
	private SequenceFile.Reader reader;

	private enum Firing {
		Count,
	}

	@Override
	public void setup(Context context) 
			throws IOException, InterruptedException {
		firstCalled = false;
	}

	private void openGraphPartition(int id, Context context) 
			throws IOException, InterruptedException {
		/*
		 * Compute the number of current graph partition 
		 */
		int reducer_num = (id - 1) / NeuronIDRangePartitioner.NumOfNeuronsPerPartition;

		/*
		 * Open the graph partition which is a sequence file generated by reducer.
		 */
		String uri;

		// After the first iteration, input for the job is the output of the previous job.
		if (reducer_num < 10) {
			uri = "adjlist" + "/" + "part-r-0000" + reducer_num;
		} else if (reducer_num < 100) { 
			uri = "adjlist" + "/" + "part-r-000" + reducer_num;
		} else {
			uri = "adjlist" + "/" + "part-r-00" + reducer_num;
		}

		Configuration conf = new Configuration();
		FileSystem fs = FileSystem.get(URI.create(uri), conf);
		Path path = new Path(uri);
		reader = new SequenceFile.Reader(fs, path, conf);
	}

	private double getGaussian() {
		return randn.nextGaussian();
	}

	private void neuronEvolution(float current, NeuronWritable neuron) {
		current += neuron.synaptic_sum;
		// Update the membrane potential. Step 0.5 ms for numerical stability. 
		neuron.potential += 0.5 * (0.04*neuron.potential*neuron.potential + 5*neuron.potential
				+ 140 - neuron.recovery + current);
		neuron.potential += 0.5 * (0.04*neuron.potential*neuron.potential + 5*neuron.potential
				+ 140 - neuron.recovery + current);
		//neuron.potential += 0.04*neuron.potential*neuron.potential + 5*neuron.potential
		//		+ 140 - neuron.recovery + current;
		// Update membrane recovery variable.
		neuron.recovery += neuron.param_a * (neuron.param_b*neuron.potential - neuron.recovery);

		// Update number of iteration
		neuron.time += 1;
		neuron.synaptic_sum = (float) 0.0;
		neuron.fired = 'N'; // Reset firing status
	}

	@Override
	public void map(IntWritable key, NeuronWritable value, Context context) 
			throws IOException, InterruptedException {

		float current;
		NeuronWritable neuron = value;

		// Generate thalamic input.
		if (neuron.type == 'e') {
			current = 5 * (float)this.getGaussian();
		} else {
			current = 2 * (float)this.getGaussian();
		}

		// Start Neuron Evolution
		this.neuronEvolution(current, neuron);
		//System.err.println(neuron.toString());

		// Check if the neuron has fired.
		if (neuron.potential >= 30.0) { // fired

			// Open graph partition if a neuron has fired. For each mapper, open once only.
			if (this.firstCalled == false) {
				this.openGraphPartition(key.get(), context);
				this.firstCalled = true;
			}

			// loop until find the right key.
			while (reader.next(adj_id, adjlist_writable)) {
				if (key.equals(adj_id)) {
					break;
				}
			}
			
			//System.err.println(value.getWritableType() + "\t" + value.getWeight() + value.getNeuronWritable().toString());
			ArrayList<SynapticWeightWritable> adjlist = adjlist_writable.toArrayList();

			// Emit synaptic weights by iterating the adjacency list.
			for (SynapticWeightWritable weight : adjlist) {
				neuron_state.setTypeOfValue('W');
				neuron_state.setWeight(weight.getWeight());
				neuron_state.setNeuron(null); // set to null to save space.

				neuron_id.set(weight.getID());

				context.write(neuron_id, neuron_state);
			}

			// Reset the membrane potential (voltage) and membrane recovery variable after firing.
			neuron.potential = neuron.param_c;
			neuron.recovery += neuron.param_d;
			neuron.fired = 'Y'; // Indicate the neuron fired at this iteration.

			context.getCounter(Firing.Count).increment(1);
		}

		neuron_state.setTypeOfValue('N');
		neuron_state.setNeuron(neuron);
		// Emit the neuron structure.
		context.write(key, neuron_state);
	}
}
